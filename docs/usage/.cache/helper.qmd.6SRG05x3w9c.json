{
    "cells": [
        {
            "id": "1",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "---\n",
                "title: Helper functions\n",
                "format:\n",
                "  html:\n",
                "    toc: true\n",
                "    number-sections: true\n",
                "engine: julia\n",
                "execute:\n",
                "  freeze: auto\n",
                "  cache: true\n",
                "---"
            ]
        },
        {
            "id": "2",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "#| output: false\n",
                "using UFFFiles"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "3",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "`UFFFiles.jl` provides several helper functions to facilitate interaction with UFF datasets.\n",
                "\n",
                "## Dataset Type\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "4",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc dataset_type"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mdataset_type(data::UFFDataset)\u001b[39m\n\n  Returns the dataset type presents in a UFFDataset object.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdata::UFFDataset\u001b[39m: The UFFDataset object to extract types from.\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mSymbol\u001b[39m: A vector containing the dataset types.",
                        "text/markdown": "```julia\ndataset_type(data::UFFDataset)\n```\n\nReturns the dataset type presents in a UFFDataset object.\n\n**Input**\n\n  * `data::UFFDataset`: The UFFDataset object to extract types from.\n\n**Output**\n\n  * `Symbol`: A vector containing the dataset types.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">dataset_type&#40;data::UFFDataset&#41;</code></pre>\n<p>Returns the dataset type presents in a UFFDataset object.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>data::UFFDataset</code>: The UFFDataset object to extract types from.</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>Symbol</code>: A vector containing the dataset types.</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\ndataset_type(data::UFFDataset)\n\\end{verbatim}\nReturns the dataset type presents in a UFFDataset object.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{data::UFFDataset}: The UFFDataset object to extract types from.\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{Symbol}: A vector containing the dataset types.\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "5",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "# Only one dataset is read\n",
                "data = readuff(\"path/to/your/file.uff\")[1]\n",
                "dtype = dataset_types(data)\n",
                "\n",
                "# Several datasets are read\n",
                "data_all = readuff(\"path/to/your/file.uff\")\n",
                "dtypes = dataset_types.(data_all)\n",
                "```\n",
                "\n",
                "## Supported Datasets\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "6",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc supported_datasets"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36msupported_datasets()\u001b[39m\n\n  Returns a vector of supported UFF dataset types.",
                        "text/markdown": "```julia\nsupported_datasets()\n```\n\nReturns a vector of supported UFF dataset types.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">supported_datasets&#40;&#41;</code></pre>\n<p>Returns a vector of supported UFF dataset types.</p>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nsupported_datasets()\n\\end{verbatim}\nReturns a vector of supported UFF dataset types.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "7",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "valid_datasets = supported_datasets()\n",
                "```\n",
                "\n",
                "## Supported file extensions\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "8",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc supported_file_extensions"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  No documentation found for public binding \u001b[36mUFFFiles.supported_file_extensions\u001b[39m.\n\n  \u001b[36mUFFFiles.supported_file_extensions\u001b[39m is a \u001b[36mFunction\u001b[39m.\n\n  \u001b[36m# 1 method for generic function \"supported_file_extensions\" from UFFFiles:\u001b[39m\n  \u001b[36m [1] supported_file_extensions()\u001b[39m\n  \u001b[36m     @ ~/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/src/uff_helpers.jl:28\u001b[39m",
                        "text/markdown": "No documentation found for public binding `UFFFiles.supported_file_extensions`.\n\n`UFFFiles.supported_file_extensions` is a `Function`.\n\n```\n# 1 method for generic function \"supported_file_extensions\" from UFFFiles:\n [1] supported_file_extensions()\n     @ ~/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/src/uff_helpers.jl:28\n```\n",
                        "text/html": "<div class=\"markdown\"><p>No documentation found for public binding <code>UFFFiles.supported_file_extensions</code>.</p>\n<p><code>UFFFiles.supported_file_extensions</code> is a <code>Function</code>.</p>\n<pre><code># 1 method for generic function &quot;supported_file_extensions&quot; from UFFFiles:\n &#91;1&#93; supported_file_extensions&#40;&#41;\n     @ ~/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/src/uff_helpers.jl:28</code></pre>\n</div>",
                        "text/latex": "No documentation found for public binding \\texttt{UFFFiles.supported\\_file\\_extensions}.\n\n\\texttt{UFFFiles.supported\\_file\\_extensions} is a \\texttt{Function}.\n\n\\begin{verbatim}\n# 1 method for generic function \"supported_file_extensions\" from UFFFiles:\n [1] supported_file_extensions()\n     @ ~/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/src/uff_helpers.jl:28\n\\end{verbatim}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "9",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "valid_file_extensions = supported_file_extensions()\n",
                "```\n",
                "\n",
                "## Connectivity Matrix\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "10",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc connectivity_matrix"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mconnectivity_matrix(dataset::Dataset2412)\u001b[39m\n\n  Returns the connectivity matrix for a Dataset2412 object, where each row\n  corresponds to an element and each column corresponds to a node. Missing\n  values are filled with \u001b[36m-1\u001b[39m.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdataset::Dataset2412\u001b[39m: The Dataset2412 object to extract\n       connectivity from.\n\n  \u001b[1mOutput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mMatrix{Int}\u001b[39m: A matrix representing the connectivity of elements to\n       nodes.",
                        "text/markdown": "```julia\nconnectivity_matrix(dataset::Dataset2412)\n```\n\nReturns the connectivity matrix for a Dataset2412 object, where each row corresponds to an element and each column corresponds to a node. Missing values are filled with `-1`.\n\n**Input**\n\n  * `dataset::Dataset2412`: The Dataset2412 object to extract connectivity from.\n\n**Output**\n\n  * `Matrix{Int}`: A matrix representing the connectivity of elements to nodes.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">connectivity_matrix&#40;dataset::Dataset2412&#41;</code></pre>\n<p>Returns the connectivity matrix for a Dataset2412 object, where each row corresponds to an element and each column corresponds to a node. Missing values are filled with <code>-1</code>.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>dataset::Dataset2412</code>: The Dataset2412 object to extract connectivity from.</p>\n</li>\n</ul>\n<p><strong>Output</strong></p>\n<ul>\n<li><p><code>Matrix&#123;Int&#125;</code>: A matrix representing the connectivity of elements to nodes.</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nconnectivity_matrix(dataset::Dataset2412)\n\\end{verbatim}\nReturns the connectivity matrix for a Dataset2412 object, where each row corresponds to an element and each column corresponds to a node. Missing values are filled with \\texttt{-1}.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{dataset::Dataset2412}: The Dataset2412 object to extract connectivity from.\n\n\\end{itemize}\n\\textbf{Output}\n\n\\begin{itemize}\n\\item \\texttt{Matrix\\{Int\\}}: A matrix representing the connectivity of elements to nodes.\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "11",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "# readuff returns a vector of datasets\n",
                "data2412 = readuff(\"path/to/your/file2412.uff\")[1]\n",
                "connectivity = connectivity_matrix(data2412)\n",
                "```\n",
                "\n",
                "## Dataset 55 to matrix\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "12",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "# | echo: false\n",
                "@doc dataset55_to_mat"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mdataset55_to_mat(dataset::Vector{Dataset55})\u001b[39m\n\n  Converts a vector of Dataset55 objects into a matrix of data values and a\n  vector of corresponding x-values based on the analysis type.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdataset::Vector{Dataset55}\u001b[39m: A vector of Dataset55 objects to be\n       converted\n\n  \u001b[1mOutputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmat::VecOrMat{dtype}\u001b[39m: A matrix where each column corresponds to a\n       dataset's data values.\n    \u001b[34m• \u001b[39m \u001b[36mx::Vector{xtype}\u001b[39m: Vector of x-values corresponding to each dataset\n       based on its analysis type.\n\n  \u001b[1mNote\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdtype\u001b[39m and \u001b[36mxtype\u001b[39m depend on the dataset's \u001b[36mdtype\u001b[39m and \u001b[36manalysis_type\u001b[39m\n       respectively.\n    \u001b[34m• \u001b[39m It is assumed that all datasets in the input vector have the same\n       number of data points and analysis type.",
                        "text/markdown": "```julia\ndataset55_to_mat(dataset::Vector{Dataset55})\n```\n\nConverts a vector of Dataset55 objects into a matrix of data values and a vector of corresponding x-values based on the analysis type.\n\n**Input**\n\n  * `dataset::Vector{Dataset55}`: A vector of Dataset55 objects to be converted\n\n**Outputs**\n\n  * `mat::VecOrMat{dtype}`: A matrix where each column corresponds to a dataset's data values.\n  * `x::Vector{xtype}`: Vector of x-values corresponding to each dataset based on its analysis type.\n\n**Note**\n\n  * `dtype` and `xtype` depend on the dataset's `dtype` and `analysis_type` respectively.\n  * It is assumed that all datasets in the input vector have the same number of data points and analysis type.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">dataset55_to_mat&#40;dataset::Vector&#123;Dataset55&#125;&#41;</code></pre>\n<p>Converts a vector of Dataset55 objects into a matrix of data values and a vector of corresponding x-values based on the analysis type.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>dataset::Vector&#123;Dataset55&#125;</code>: A vector of Dataset55 objects to be converted</p>\n</li>\n</ul>\n<p><strong>Outputs</strong></p>\n<ul>\n<li><p><code>mat::VecOrMat&#123;dtype&#125;</code>: A matrix where each column corresponds to a dataset&#39;s data values.</p>\n</li>\n<li><p><code>x::Vector&#123;xtype&#125;</code>: Vector of x-values corresponding to each dataset based on its analysis type.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<ul>\n<li><p><code>dtype</code> and <code>xtype</code> depend on the dataset&#39;s <code>dtype</code> and <code>analysis_type</code> respectively.</p>\n</li>\n<li><p>It is assumed that all datasets in the input vector have the same number of data points and analysis type.</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\ndataset55_to_mat(dataset::Vector{Dataset55})\n\\end{verbatim}\nConverts a vector of Dataset55 objects into a matrix of data values and a vector of corresponding x-values based on the analysis type.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{dataset::Vector\\{Dataset55\\}}: A vector of Dataset55 objects to be converted\n\n\\end{itemize}\n\\textbf{Outputs}\n\n\\begin{itemize}\n\\item \\texttt{mat::VecOrMat\\{dtype\\}}: A matrix where each column corresponds to a dataset's data values.\n\n\n\\item \\texttt{x::Vector\\{xtype\\}}: Vector of x-values corresponding to each dataset based on its analysis type.\n\n\\end{itemize}\n\\textbf{Note}\n\n\\begin{itemize}\n\\item \\texttt{dtype} and \\texttt{xtype} depend on the dataset's \\texttt{dtype} and \\texttt{analysis\\_type} respectively.\n\n\n\\item It is assumed that all datasets in the input vector have the same number of data points and analysis type.\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "13",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "# Let's assume you have read a UFF file containing dataset 55 only\n",
                "data55 = readuff(\"path/to/your/file55.uff\")\n",
                "\n",
                "# Convert dataset 55 to a matrix\n",
                "matrix55, x = dataset55_to_mat(data55)\n",
                "```\n",
                "\n",
                "## Dataset 58 to matrix\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "14",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "# | echo: false\n",
                "@doc dataset58_to_mat"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mdataset58_to_mat(dataset::Vector{Dataset58})\u001b[39m\n\n  Converts a vector of Dataset58 objects into a matrix of data values and a\n  vector of corresponding x-values based on the dataset parameters.\n\n  \u001b[1mInput\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdataset::Vector{Dataset58}\u001b[39m: A vector of Dataset58 objects to be\n       converted\n\n  \u001b[1mOutputs\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mmat::VecOrMat{dtype}\u001b[39m: A matrix where each row corresponds to a\n       dataset's data values.\n    \u001b[34m• \u001b[39m \u001b[36mx::Vector{xtype}\u001b[39m: A vector of x-values corresponding to each\n       dataset based on its parameters.\n\n  \u001b[1mNote\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mdtype\u001b[39m and \u001b[36mxtype\u001b[39m depend on the dataset's \u001b[36mord_dtype\u001b[39m.\n    \u001b[34m• \u001b[39m It is assumed that all datasets in the input vector have the same\n       number of data points and data type.",
                        "text/markdown": "```julia\ndataset58_to_mat(dataset::Vector{Dataset58})\n```\n\nConverts a vector of Dataset58 objects into a matrix of data values and a vector of corresponding x-values based on the dataset parameters.\n\n**Input**\n\n  * `dataset::Vector{Dataset58}`: A vector of Dataset58 objects to be converted\n\n**Outputs**\n\n  * `mat::VecOrMat{dtype}`: A matrix where each row corresponds to a dataset's data values.\n  * `x::Vector{xtype}`: A vector of x-values corresponding to each dataset based on its parameters.\n\n**Note**\n\n  * `dtype` and `xtype` depend on the dataset's `ord_dtype`.\n  * It is assumed that all datasets in the input vector have the same number of data points and data type.\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">dataset58_to_mat&#40;dataset::Vector&#123;Dataset58&#125;&#41;</code></pre>\n<p>Converts a vector of Dataset58 objects into a matrix of data values and a vector of corresponding x-values based on the dataset parameters.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li><p><code>dataset::Vector&#123;Dataset58&#125;</code>: A vector of Dataset58 objects to be converted</p>\n</li>\n</ul>\n<p><strong>Outputs</strong></p>\n<ul>\n<li><p><code>mat::VecOrMat&#123;dtype&#125;</code>: A matrix where each row corresponds to a dataset&#39;s data values.</p>\n</li>\n<li><p><code>x::Vector&#123;xtype&#125;</code>: A vector of x-values corresponding to each dataset based on its parameters.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<ul>\n<li><p><code>dtype</code> and <code>xtype</code> depend on the dataset&#39;s <code>ord_dtype</code>.</p>\n</li>\n<li><p>It is assumed that all datasets in the input vector have the same number of data points and data type.</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\ndataset58_to_mat(dataset::Vector{Dataset58})\n\\end{verbatim}\nConverts a vector of Dataset58 objects into a matrix of data values and a vector of corresponding x-values based on the dataset parameters.\n\n\\textbf{Input}\n\n\\begin{itemize}\n\\item \\texttt{dataset::Vector\\{Dataset58\\}}: A vector of Dataset58 objects to be converted\n\n\\end{itemize}\n\\textbf{Outputs}\n\n\\begin{itemize}\n\\item \\texttt{mat::VecOrMat\\{dtype\\}}: A matrix where each row corresponds to a dataset's data values.\n\n\n\\item \\texttt{x::Vector\\{xtype\\}}: A vector of x-values corresponding to each dataset based on its parameters.\n\n\\end{itemize}\n\\textbf{Note}\n\n\\begin{itemize}\n\\item \\texttt{dtype} and \\texttt{xtype} depend on the dataset's \\texttt{ord\\_dtype}.\n\n\n\\item It is assumed that all datasets in the input vector have the same number of data points and data type.\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "15",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::\n",
                "\n",
                "```julia\n",
                "using UFFFiles\n",
                "\n",
                "# Let's assume you have read a UFF file containing dataset 58 only\n",
                "data58 = readuff(\"path/to/your/file58.uff\")\n",
                "\n",
                "# Convert dataset 58 to a matrix\n",
                "matrix58, x = dataset58_to_matrix(data58)\n",
                "```"
            ]
        }
    ],
    "timestamp": "2025-11-24T14:27:42.833",
    "file": "/Users/maucejo/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/docs/usage/helper.qmd",
    "qnr_schema_version": "1.0.0"
}