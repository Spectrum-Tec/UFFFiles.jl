{
    "cells": [
        {
            "id": "1",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "---\n",
                "title: Dataset 58b - Function at nodal DOF (binary)\n",
                "format:\n",
                "  html:\n",
                "    toc: true\n",
                "    number-sections: true\n",
                "engine: julia\n",
                "execute:\n",
                "  freeze: auto\n",
                "  cache: true\n",
                "---"
            ]
        },
        {
            "id": "2",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "#| output: false\n",
                "using UFFFiles"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "3",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "## Dataset description"
            ]
        },
        {
            "id": "4",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc UFFFiles.parse_dataset58b"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  The Binary 58 Universal File Format (UFF):\n\n  The basic (ASCII) universal file format for data is universal file format\n\n    \u001b[34m58.\u001b[39m This format is completely documented by SDRC and a copy of that\n\n  documentation is on the UC-SDRL web site (58.asc). The universal file format\n  always begins with two records that are prior to the information defined by\n  each universal file format and ends with a record that is placed after the\n  information defined by the format. First of all, all records are 80\n  character ASCII records for the basic universal file format. The first and\n  last record are start/stop records and are always -1 in the first six\n  columns, right justified (Fortran I6 field with -1 in the field). The second\n  record (Identifier Record) always contains the universal file format number\n  in the first 6 columns, right justified.\n\n  This gives a file structure as follows (where b represent a blank character):\n\n  bbbb-1 bbbb58 ... ... ... bbbb-1\n\n  The Binary 58 universal file format was originally developed by UC-SDRL in\n  order to eliminate the need to compress the UFF 58 records and to reduce the\n  time required to load the UFF 58 data records. The Binary 58 universal file\n  format yields files that are comparable to compressed files (approximately 3\n  to 4 times smaller than the equivalent UFF 58 file). The Binary 58 universal\n  file format loads approximately 30 to 40 times faster than the equivalent\n  UFF 58 file, depending upon the computing environment. This new format was\n  submitted to SDRC and subsequently adopted as a supported format.\n\n  The Binary 58 universal file format uses the same ASCII records at the start\n  of each data file as the ASCII dataset 58 but, beginning with record 12, the\n  data is stored in binary form rather than the specified ASCII format. The\n  identifier record has the same 58 identifier in the first six columns, right\n  justified, but has additional information in the rest of the 80 character\n  record that identifies the binary format (the size of the binary record, the\n  format of the binary structure, etc.).\n\n  \u001b[36m-1\u001b[39m\n  \u001b[36m58b     x     y          11        zzzz     0     0           0           0\u001b[39m\n\n  ... ... (11 ASCII header lines) ... ... ... (zzzz BINARY bytes of data, in\n  format specifed by x and y, above) ... (interleaved as specified by the\n  ASCII dataset 58) ... -1\n\n  When reading or writing a dataset 58b, care must be taken that the binary\n  data immediately follows the ASCII header lines and the closing ' -1'\n  immediately follows the binary data. The binary data content is written in\n  the same sequence as the ASCII dataset 58 (ie. field order sequence). The\n  field size is NOT used, however the data type (int/float/double) content is.\n  Note: there are no CR/LF characters embedded in or following the binary data.\n\n  ===================================================================== The\n  Format of 58b ID-Line: ––––––––––––––\n\n  For the traditional dataset 58 (Function at Nodal DOF), the dataset id-line\n  is composed of four spaces followed by \"58\". This line has been enhanced to\n  contain additional information for the binary version of dataset 58.\n\n  \u001b[36m-1\u001b[39m\n  \u001b[36m58b     2     2          11        4096     0     0           0           0\u001b[39m\n  \n  \u001b[36m Format (I6,1A1,I6,I6,I12,I12,I6,I6,I12,I12)\u001b[39m\n  \n  \u001b[36m          Field 1       - 58  [I6]\u001b[39m\n  \u001b[36m          Field 2       - lowercase b [1A1]\u001b[39m\n  \u001b[36m          Field 3       - Byte Ordering Method [I6]\u001b[39m\n  \u001b[36m                          1 - Little Endian (DEC VMS & ULTRIX, WIN NT)\u001b[39m\n  \u001b[36m                          2 - Big Endian (most UNIX)\u001b[39m\n  \u001b[36m          Field 4       - Floating Point Format [I6]\u001b[39m\n  \u001b[36m                          1 - DEC VMS\u001b[39m\n  \u001b[36m                          2 - IEEE 754 (UNIX)\u001b[39m\n  \u001b[36m                          3 - IBM 5/370\u001b[39m\n  \u001b[36m          Field 5       - number of ASCII lines following  [I12]\u001b[39m\n  \u001b[36m                          11 - \u001b[31mfor dataset 58\u001b[39m\n  \u001b[36m          Field 6       - number of bytes following ASCII lines  [I12]\u001b[39m\n  \u001b[36m          Fields 7-10   - Not used (fill with zeros)\u001b[39m\n\n  The format of this line should remain constant for any other dataset that\n  takes on a binary format in the future.",
                        "text/markdown": "The Binary 58 Universal File Format (UFF):\n\nThe basic (ASCII) universal file format for data is universal file format\n\n58. This format is completely documented by SDRC and a copy of that\n\ndocumentation is on the UC-SDRL web site (58.asc). The universal file format always begins with two records that are prior to the information defined by each universal file format and ends with a record that is placed after the information defined by the format.   First of all, all records are 80 character ASCII records for the basic universal file format. The first and last record are start/stop records and are always -1 in the first six columns, right justified (Fortran I6 field with -1 in the field).  The second record (Identifier Record) always contains the universal file format number in the first 6 columns, right justified.\n\nThis gives a file structure as follows (where b represent a blank character):\n\nbbbb-1 bbbb58 ... ... ... bbbb-1\n\nThe Binary 58 universal file format was originally developed by UC-SDRL in order to eliminate the need to compress the UFF 58 records and to reduce the time required to load the UFF 58 data records.  The Binary 58 universal file format yields files that are comparable to compressed files (approximately 3 to 4 times smaller than the equivalent UFF 58 file).  The Binary 58 universal file format loads approximately 30 to 40 times faster than the equivalent UFF 58 file, depending upon the computing environment.  This new format was submitted to SDRC and subsequently adopted as a supported format.\n\nThe Binary 58 universal file format uses the same ASCII records at the start of each data file as the ASCII dataset 58 but, beginning with record 12, the data is stored in binary form rather than the specified ASCII format.  The identifier record has the same 58 identifier in the first six columns, right justified, but has additional information in the rest of the 80 character record that identifies the binary format (the size of the binary record, the format of the binary structure, etc.).\n\n```julia\n-1\n58b     x     y          11        zzzz     0     0           0           0\n```\n\n... ... (11 ASCII header lines) ... ... ... (zzzz BINARY bytes of data, in format specifed by x and y, above) ... (interleaved as specified by the ASCII dataset 58) ...     -1\n\nWhen reading or writing a dataset 58b, care must be taken that the binary data immediately follows the ASCII header lines and the closing '    -1' immediately follows the binary data.  The binary data content is written in the same sequence as the ASCII dataset 58 (ie. field order sequence).  The field size is NOT used, however the data type (int/float/double) content is.  Note: there are no CR/LF characters embedded in or following the binary data.\n\n===================================================================== The Format of 58b ID-Line: ––––––––––––––\n\nFor the traditional dataset 58 (Function at Nodal DOF), the dataset id-line is composed of four spaces followed by \"58\". This line has been enhanced to contain additional information for the binary version of dataset 58.\n\n```julia\n-1\n58b     2     2          11        4096     0     0           0           0\n\n Format (I6,1A1,I6,I6,I12,I12,I6,I6,I12,I12)\n\n          Field 1       - 58  [I6]\n          Field 2       - lowercase b [1A1]\n          Field 3       - Byte Ordering Method [I6]\n                          1 - Little Endian (DEC VMS & ULTRIX, WIN NT)\n                          2 - Big Endian (most UNIX)\n          Field 4       - Floating Point Format [I6]\n                          1 - DEC VMS\n                          2 - IEEE 754 (UNIX)\n                          3 - IBM 5/370\n          Field 5       - number of ASCII lines following  [I12]\n                          11 - for dataset 58\n          Field 6       - number of bytes following ASCII lines  [I12]\n          Fields 7-10   - Not used (fill with zeros)\n```\n\nThe format of this line should remain constant for any other dataset that takes on a binary format in the future.\n",
                        "text/html": "<div class=\"markdown\"><p>The Binary 58 Universal File Format &#40;UFF&#41;:</p>\n<p>The basic &#40;ASCII&#41; universal file format for data is universal file format</p>\n<ol start=\"58\">\n<li><p>This format is completely documented by SDRC and a copy of that</p>\n</li>\n</ol>\n<p>documentation is on the UC-SDRL web site &#40;58.asc&#41;. The universal file format always begins with two records that are prior to the information defined by each universal file format and ends with a record that is placed after the information defined by the format.   First of all, all records are 80 character ASCII records for the basic universal file format. The first and last record are start/stop records and are always -1 in the first six columns, right justified &#40;Fortran I6 field with -1 in the field&#41;.  The second record &#40;Identifier Record&#41; always contains the universal file format number in the first 6 columns, right justified.</p>\n<p>This gives a file structure as follows &#40;where b represent a blank character&#41;:</p>\n<p>bbbb-1 bbbb58 ... ... ... bbbb-1</p>\n<p>The Binary 58 universal file format was originally developed by UC-SDRL in order to eliminate the need to compress the UFF 58 records and to reduce the time required to load the UFF 58 data records.  The Binary 58 universal file format yields files that are comparable to compressed files &#40;approximately 3 to 4 times smaller than the equivalent UFF 58 file&#41;.  The Binary 58 universal file format loads approximately 30 to 40 times faster than the equivalent UFF 58 file, depending upon the computing environment.  This new format was submitted to SDRC and subsequently adopted as a supported format.</p>\n<p>The Binary 58 universal file format uses the same ASCII records at the start of each data file as the ASCII dataset 58 but, beginning with record 12, the data is stored in binary form rather than the specified ASCII format.  The identifier record has the same 58 identifier in the first six columns, right justified, but has additional information in the rest of the 80 character record that identifies the binary format &#40;the size of the binary record, the format of the binary structure, etc.&#41;.</p>\n<pre><code class=\"language-julia\">-1\n58b     x     y          11        zzzz     0     0           0           0</code></pre>\n<p>... ... &#40;11 ASCII header lines&#41; ... ... ... &#40;zzzz BINARY bytes of data, in format specifed by x and y, above&#41; ... &#40;interleaved as specified by the ASCII dataset 58&#41; ...     -1</p>\n<p>When reading or writing a dataset 58b, care must be taken that the binary data immediately follows the ASCII header lines and the closing &#39;    -1&#39; immediately follows the binary data.  The binary data content is written in the same sequence as the ASCII dataset 58 &#40;ie. field order sequence&#41;.  The field size is NOT used, however the data type &#40;int/float/double&#41; content is.  Note: there are no CR/LF characters embedded in or following the binary data.</p>\n<p>&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61; The Format of 58b ID-Line: ––––––––––––––</p>\n<p>For the traditional dataset 58 &#40;Function at Nodal DOF&#41;, the dataset id-line is composed of four spaces followed by &quot;58&quot;. This line has been enhanced to contain additional information for the binary version of dataset 58.</p>\n<pre><code class=\"language-julia\">-1\n58b     2     2          11        4096     0     0           0           0\n\n Format &#40;I6,1A1,I6,I6,I12,I12,I6,I6,I12,I12&#41;\n\n          Field 1       - 58  &#91;I6&#93;\n          Field 2       - lowercase b &#91;1A1&#93;\n          Field 3       - Byte Ordering Method &#91;I6&#93;\n                          1 - Little Endian &#40;DEC VMS &amp; ULTRIX, WIN NT&#41;\n                          2 - Big Endian &#40;most UNIX&#41;\n          Field 4       - Floating Point Format &#91;I6&#93;\n                          1 - DEC VMS\n                          2 - IEEE 754 &#40;UNIX&#41;\n                          3 - IBM 5/370\n          Field 5       - number of ASCII lines following  &#91;I12&#93;\n                          11 - for dataset 58\n          Field 6       - number of bytes following ASCII lines  &#91;I12&#93;\n          Fields 7-10   - Not used &#40;fill with zeros&#41;</code></pre>\n<p>The format of this line should remain constant for any other dataset that takes on a binary format in the future.</p>\n\n\n</div>",
                        "text/latex": "The Binary 58 Universal File Format (UFF):\n\nThe basic (ASCII) universal file format for data is universal file format\n\n\\begin{itemize}\n\\item[58. ] This format is completely documented by SDRC and a copy of that\n\n\\end{itemize}\ndocumentation is on the UC-SDRL web site (58.asc). The universal file format always begins with two records that are prior to the information defined by each universal file format and ends with a record that is placed after the information defined by the format.   First of all, all records are 80 character ASCII records for the basic universal file format. The first and last record are start/stop records and are always -1 in the first six columns, right justified (Fortran I6 field with -1 in the field).  The second record (Identifier Record) always contains the universal file format number in the first 6 columns, right justified.\n\nThis gives a file structure as follows (where b represent a blank character):\n\nbbbb-1 bbbb58 ... ... ... bbbb-1\n\nThe Binary 58 universal file format was originally developed by UC-SDRL in order to eliminate the need to compress the UFF 58 records and to reduce the time required to load the UFF 58 data records.  The Binary 58 universal file format yields files that are comparable to compressed files (approximately 3 to 4 times smaller than the equivalent UFF 58 file).  The Binary 58 universal file format loads approximately 30 to 40 times faster than the equivalent UFF 58 file, depending upon the computing environment.  This new format was submitted to SDRC and subsequently adopted as a supported format.\n\nThe Binary 58 universal file format uses the same ASCII records at the start of each data file as the ASCII dataset 58 but, beginning with record 12, the data is stored in binary form rather than the specified ASCII format.  The identifier record has the same 58 identifier in the first six columns, right justified, but has additional information in the rest of the 80 character record that identifies the binary format (the size of the binary record, the format of the binary structure, etc.).\n\n\\begin{verbatim}\n-1\n58b     x     y          11        zzzz     0     0           0           0\n\\end{verbatim}\n... ... (11 ASCII header lines) ... ... ... (zzzz BINARY bytes of data, in format specifed by x and y, above) ... (interleaved as specified by the ASCII dataset 58) ...     -1\n\nWhen reading or writing a dataset 58b, care must be taken that the binary data immediately follows the ASCII header lines and the closing '    -1' immediately follows the binary data.  The binary data content is written in the same sequence as the ASCII dataset 58 (ie. field order sequence).  The field size is NOT used, however the data type (int/float/double) content is.  Note: there are no CR/LF characters embedded in or following the binary data.\n\n===================================================================== The Format of 58b ID-Line: ––––––––––––––\n\nFor the traditional dataset 58 (Function at Nodal DOF), the dataset id-line is composed of four spaces followed by \"58\". This line has been enhanced to contain additional information for the binary version of dataset 58.\n\n\\begin{verbatim}\n-1\n58b     2     2          11        4096     0     0           0           0\n\n Format (I6,1A1,I6,I6,I12,I12,I6,I6,I12,I12)\n\n          Field 1       - 58  [I6]\n          Field 2       - lowercase b [1A1]\n          Field 3       - Byte Ordering Method [I6]\n                          1 - Little Endian (DEC VMS & ULTRIX, WIN NT)\n                          2 - Big Endian (most UNIX)\n          Field 4       - Floating Point Format [I6]\n                          1 - DEC VMS\n                          2 - IEEE 754 (UNIX)\n                          3 - IBM 5/370\n          Field 5       - number of ASCII lines following  [I12]\n                          11 - for dataset 58\n          Field 6       - number of bytes following ASCII lines  [I12]\n          Fields 7-10   - Not used (fill with zeros)\n\\end{verbatim}\nThe format of this line should remain constant for any other dataset that takes on a binary format in the future.\n\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "5",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "## API\n",
                "\n",
                "::: {.api}"
            ]
        },
        {
            "id": "6",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "#| echo: false\n",
                "@doc Dataset58"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "  \u001b[36mDataset58\u001b[39m\n\n  A struct containing UFF Dataset 58 (Function at nodal dof) data.\n\n  \u001b[1mFields\u001b[22m\n\n    \u001b[34m• \u001b[39m \u001b[36mtype::Symbol\u001b[39m: Data set type\n    \u001b[34m• \u001b[39m \u001b[36mname::String\u001b[39m: Data set name\n    \u001b[34m• \u001b[39m \u001b[36mid1::String\u001b[39m: ID line 1\n    \u001b[34m• \u001b[39m \u001b[36mid2::String\u001b[39m: ID line 2\n    \u001b[34m• \u001b[39m \u001b[36mid3::String\u001b[39m: ID line 3\n    \u001b[34m• \u001b[39m \u001b[36mid4::String\u001b[39m: ID line 4\n    \u001b[34m• \u001b[39m \u001b[36mid5::String\u001b[39m: ID line 5\n    \u001b[34m• \u001b[39m \u001b[36mfunc_type::Int\u001b[39m: Function type\n    \u001b[34m• \u001b[39m \u001b[36mfunc_id::Int\u001b[39m: Function ID\n    \u001b[34m• \u001b[39m \u001b[36mver_num::Int\u001b[39m: Version number\n    \u001b[34m• \u001b[39m \u001b[36mload_case::Int\u001b[39m: Load case\n    \u001b[34m• \u001b[39m \u001b[36mresp_name::String\u001b[39m: Response name\n    \u001b[34m• \u001b[39m \u001b[36mresp_node::Int\u001b[39m: Response node\n    \u001b[34m• \u001b[39m \u001b[36mresp_dir::Int\u001b[39m: Response direction\n    \u001b[34m• \u001b[39m \u001b[36mref_name::String\u001b[39m: Reference name\n    \u001b[34m• \u001b[39m \u001b[36mref_node::Int\u001b[39m: Reference node\n    \u001b[34m• \u001b[39m \u001b[36mref_dir::Int\u001b[39m: Reference direction\n    \u001b[34m• \u001b[39m \u001b[36mord_dtype::Int\u001b[39m: Ordinate data type\n    \u001b[34m• \u001b[39m \u001b[36mnum_pts::Int\u001b[39m: Number of points\n    \u001b[34m• \u001b[39m \u001b[36mabs_spacing_type::Int\u001b[39m: Abscissa spacing type\n    \u001b[34m• \u001b[39m \u001b[36mabs_start::Float64\u001b[39m: Abscissa start\n    \u001b[34m• \u001b[39m \u001b[36mabs_increment::Float64\u001b[39m: Abscissa increment\n    \u001b[34m• \u001b[39m \u001b[36mzval::Float64\u001b[39m: Z-axis value\n    \u001b[34m• \u001b[39m \u001b[36mabs_spec_dtype::Int\u001b[39m: Abscissa specification data type\n    \u001b[34m• \u001b[39m \u001b[36mabs_len_unit_exp::Int\u001b[39m: Abscissa length unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mabs_force_unit_exp::Int\u001b[39m: Abscissa force unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mabs_temp_unit_exp::Int\u001b[39m: Abscissa temperature unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mabs_axis_label::String\u001b[39m: Abscissa axis label\n    \u001b[34m• \u001b[39m \u001b[36mabs_axis_unit_label::String\u001b[39m: Abscissa axis unit label\n    \u001b[34m• \u001b[39m \u001b[36mord_spec_dtype::Int\u001b[39m: Ordinate specification data type\n    \u001b[34m• \u001b[39m \u001b[36mord_len_unit_exp::Int\u001b[39m: Ordinate length unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_force_unit_exp::Int\u001b[39m: Ordinate force unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_temp_unit_exp::Int\u001b[39m: Ordinate temperature unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_axis_label::String\u001b[39m: Ordinate axis label\n    \u001b[34m• \u001b[39m \u001b[36mord_axis_unit_label::String\u001b[39m: Ordinate axis unit label\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_spec_dtype::Int\u001b[39m: Ordinate denominator specification data\n       type\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_len_unit_exp::Int\u001b[39m: Ordinate denominator length unit\n       exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_force_unit_exp::Int\u001b[39m: Ordinate denominator force unit\n       exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_temp_unit_exp::Int\u001b[39m: Ordinate denominator temperature\n       unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_axis_label::String\u001b[39m: Ordinate denominator axis label\n    \u001b[34m• \u001b[39m \u001b[36mord_denom_axis_unit_label::String\u001b[39m: Ordinate denominator axis unit\n       label\n    \u001b[34m• \u001b[39m \u001b[36mz_spec_dtype::Int\u001b[39m: Z-axis specification data type\n    \u001b[34m• \u001b[39m \u001b[36mz_len_unit_exp::Int\u001b[39m: Z-axis length unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mz_force_unit_exp::Int\u001b[39m: Z-axis force unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mz_temp_unit_exp::Int\u001b[39m: Z-axis temperature unit exponent\n    \u001b[34m• \u001b[39m \u001b[36mz_axis_label::String\u001b[39m: Z-axis label\n    \u001b[34m• \u001b[39m \u001b[36mz_axis_unit_label::String\u001b[39m: Z-axis unit label\n    \u001b[34m• \u001b[39m \u001b[36mabscissa\u001b[39m - Data Values (empty if evenly spaced otherwise filled in)\n    \u001b[34m• \u001b[39m \u001b[36mdata::AbstractVector\u001b[39m: Data values",
                        "text/markdown": "```julia\nDataset58\n```\n\nA struct containing UFF Dataset 58 (Function at nodal dof) data.\n\n**Fields**\n\n  * `type::Symbol`: Data set type\n  * `name::String`: Data set name\n  * `id1::String`: ID line 1\n  * `id2::String`: ID line 2\n  * `id3::String`: ID line 3\n  * `id4::String`: ID line 4\n  * `id5::String`: ID line 5\n  * `func_type::Int`: Function type\n  * `func_id::Int`: Function ID\n  * `ver_num::Int`: Version number\n  * `load_case::Int`: Load case\n  * `resp_name::String`: Response name\n  * `resp_node::Int`: Response node\n  * `resp_dir::Int`: Response direction\n  * `ref_name::String`: Reference name\n  * `ref_node::Int`: Reference node\n  * `ref_dir::Int`: Reference direction\n  * `ord_dtype::Int`: Ordinate data type\n  * `num_pts::Int`: Number of points\n  * `abs_spacing_type::Int`: Abscissa spacing type\n  * `abs_start::Float64`: Abscissa start\n  * `abs_increment::Float64`: Abscissa increment\n  * `zval::Float64`: Z-axis value\n  * `abs_spec_dtype::Int`: Abscissa specification data type\n  * `abs_len_unit_exp::Int`: Abscissa length unit exponent\n  * `abs_force_unit_exp::Int`: Abscissa force unit exponent\n  * `abs_temp_unit_exp::Int`: Abscissa temperature unit exponent\n  * `abs_axis_label::String`: Abscissa axis label\n  * `abs_axis_unit_label::String`: Abscissa axis unit label\n  * `ord_spec_dtype::Int`: Ordinate specification data type\n  * `ord_len_unit_exp::Int`: Ordinate length unit exponent\n  * `ord_force_unit_exp::Int`: Ordinate force unit exponent\n  * `ord_temp_unit_exp::Int`: Ordinate temperature unit exponent\n  * `ord_axis_label::String`: Ordinate axis label\n  * `ord_axis_unit_label::String`: Ordinate axis unit label\n  * `ord_denom_spec_dtype::Int`: Ordinate denominator specification data type\n  * `ord_denom_len_unit_exp::Int`: Ordinate denominator length unit exponent\n  * `ord_denom_force_unit_exp::Int`: Ordinate denominator force unit exponent\n  * `ord_denom_temp_unit_exp::Int`: Ordinate denominator temperature unit exponent\n  * `ord_denom_axis_label::String`: Ordinate denominator axis label\n  * `ord_denom_axis_unit_label::String`: Ordinate denominator axis unit label\n  * `z_spec_dtype::Int`: Z-axis specification data type\n  * `z_len_unit_exp::Int`: Z-axis length unit exponent\n  * `z_force_unit_exp::Int`: Z-axis force unit exponent\n  * `z_temp_unit_exp::Int`: Z-axis temperature unit exponent\n  * `z_axis_label::String`: Z-axis label\n  * `z_axis_unit_label::String`: Z-axis unit label\n  * `abscissa` - Data Values (empty if evenly spaced otherwise filled in)\n  * `data::AbstractVector`: Data values\n",
                        "text/html": "<div class=\"markdown\"><pre><code class=\"language-julia\">Dataset58</code></pre>\n<p>A struct containing UFF Dataset 58 &#40;Function at nodal dof&#41; data.</p>\n<p><strong>Fields</strong></p>\n<ul>\n<li><p><code>type::Symbol</code>: Data set type</p>\n</li>\n<li><p><code>name::String</code>: Data set name</p>\n</li>\n<li><p><code>id1::String</code>: ID line 1</p>\n</li>\n<li><p><code>id2::String</code>: ID line 2</p>\n</li>\n<li><p><code>id3::String</code>: ID line 3</p>\n</li>\n<li><p><code>id4::String</code>: ID line 4</p>\n</li>\n<li><p><code>id5::String</code>: ID line 5</p>\n</li>\n<li><p><code>func_type::Int</code>: Function type</p>\n</li>\n<li><p><code>func_id::Int</code>: Function ID</p>\n</li>\n<li><p><code>ver_num::Int</code>: Version number</p>\n</li>\n<li><p><code>load_case::Int</code>: Load case</p>\n</li>\n<li><p><code>resp_name::String</code>: Response name</p>\n</li>\n<li><p><code>resp_node::Int</code>: Response node</p>\n</li>\n<li><p><code>resp_dir::Int</code>: Response direction</p>\n</li>\n<li><p><code>ref_name::String</code>: Reference name</p>\n</li>\n<li><p><code>ref_node::Int</code>: Reference node</p>\n</li>\n<li><p><code>ref_dir::Int</code>: Reference direction</p>\n</li>\n<li><p><code>ord_dtype::Int</code>: Ordinate data type</p>\n</li>\n<li><p><code>num_pts::Int</code>: Number of points</p>\n</li>\n<li><p><code>abs_spacing_type::Int</code>: Abscissa spacing type</p>\n</li>\n<li><p><code>abs_start::Float64</code>: Abscissa start</p>\n</li>\n<li><p><code>abs_increment::Float64</code>: Abscissa increment</p>\n</li>\n<li><p><code>zval::Float64</code>: Z-axis value</p>\n</li>\n<li><p><code>abs_spec_dtype::Int</code>: Abscissa specification data type</p>\n</li>\n<li><p><code>abs_len_unit_exp::Int</code>: Abscissa length unit exponent</p>\n</li>\n<li><p><code>abs_force_unit_exp::Int</code>: Abscissa force unit exponent</p>\n</li>\n<li><p><code>abs_temp_unit_exp::Int</code>: Abscissa temperature unit exponent</p>\n</li>\n<li><p><code>abs_axis_label::String</code>: Abscissa axis label</p>\n</li>\n<li><p><code>abs_axis_unit_label::String</code>: Abscissa axis unit label</p>\n</li>\n<li><p><code>ord_spec_dtype::Int</code>: Ordinate specification data type</p>\n</li>\n<li><p><code>ord_len_unit_exp::Int</code>: Ordinate length unit exponent</p>\n</li>\n<li><p><code>ord_force_unit_exp::Int</code>: Ordinate force unit exponent</p>\n</li>\n<li><p><code>ord_temp_unit_exp::Int</code>: Ordinate temperature unit exponent</p>\n</li>\n<li><p><code>ord_axis_label::String</code>: Ordinate axis label</p>\n</li>\n<li><p><code>ord_axis_unit_label::String</code>: Ordinate axis unit label</p>\n</li>\n<li><p><code>ord_denom_spec_dtype::Int</code>: Ordinate denominator specification data type</p>\n</li>\n<li><p><code>ord_denom_len_unit_exp::Int</code>: Ordinate denominator length unit exponent</p>\n</li>\n<li><p><code>ord_denom_force_unit_exp::Int</code>: Ordinate denominator force unit exponent</p>\n</li>\n<li><p><code>ord_denom_temp_unit_exp::Int</code>: Ordinate denominator temperature unit exponent</p>\n</li>\n<li><p><code>ord_denom_axis_label::String</code>: Ordinate denominator axis label</p>\n</li>\n<li><p><code>ord_denom_axis_unit_label::String</code>: Ordinate denominator axis unit label</p>\n</li>\n<li><p><code>z_spec_dtype::Int</code>: Z-axis specification data type</p>\n</li>\n<li><p><code>z_len_unit_exp::Int</code>: Z-axis length unit exponent</p>\n</li>\n<li><p><code>z_force_unit_exp::Int</code>: Z-axis force unit exponent</p>\n</li>\n<li><p><code>z_temp_unit_exp::Int</code>: Z-axis temperature unit exponent</p>\n</li>\n<li><p><code>z_axis_label::String</code>: Z-axis label</p>\n</li>\n<li><p><code>z_axis_unit_label::String</code>: Z-axis unit label</p>\n</li>\n<li><p><code>abscissa</code> - Data Values &#40;empty if evenly spaced otherwise filled in&#41;</p>\n</li>\n<li><p><code>data::AbstractVector</code>: Data values</p>\n</li>\n</ul>\n\n\n</div>",
                        "text/latex": "\\begin{verbatim}\nDataset58\n\\end{verbatim}\nA struct containing UFF Dataset 58 (Function at nodal dof) data.\n\n\\textbf{Fields}\n\n\\begin{itemize}\n\\item \\texttt{type::Symbol}: Data set type\n\n\n\\item \\texttt{name::String}: Data set name\n\n\n\\item \\texttt{id1::String}: ID line 1\n\n\n\\item \\texttt{id2::String}: ID line 2\n\n\n\\item \\texttt{id3::String}: ID line 3\n\n\n\\item \\texttt{id4::String}: ID line 4\n\n\n\\item \\texttt{id5::String}: ID line 5\n\n\n\\item \\texttt{func\\_type::Int}: Function type\n\n\n\\item \\texttt{func\\_id::Int}: Function ID\n\n\n\\item \\texttt{ver\\_num::Int}: Version number\n\n\n\\item \\texttt{load\\_case::Int}: Load case\n\n\n\\item \\texttt{resp\\_name::String}: Response name\n\n\n\\item \\texttt{resp\\_node::Int}: Response node\n\n\n\\item \\texttt{resp\\_dir::Int}: Response direction\n\n\n\\item \\texttt{ref\\_name::String}: Reference name\n\n\n\\item \\texttt{ref\\_node::Int}: Reference node\n\n\n\\item \\texttt{ref\\_dir::Int}: Reference direction\n\n\n\\item \\texttt{ord\\_dtype::Int}: Ordinate data type\n\n\n\\item \\texttt{num\\_pts::Int}: Number of points\n\n\n\\item \\texttt{abs\\_spacing\\_type::Int}: Abscissa spacing type\n\n\n\\item \\texttt{abs\\_start::Float64}: Abscissa start\n\n\n\\item \\texttt{abs\\_increment::Float64}: Abscissa increment\n\n\n\\item \\texttt{zval::Float64}: Z-axis value\n\n\n\\item \\texttt{abs\\_spec\\_dtype::Int}: Abscissa specification data type\n\n\n\\item \\texttt{abs\\_len\\_unit\\_exp::Int}: Abscissa length unit exponent\n\n\n\\item \\texttt{abs\\_force\\_unit\\_exp::Int}: Abscissa force unit exponent\n\n\n\\item \\texttt{abs\\_temp\\_unit\\_exp::Int}: Abscissa temperature unit exponent\n\n\n\\item \\texttt{abs\\_axis\\_label::String}: Abscissa axis label\n\n\n\\item \\texttt{abs\\_axis\\_unit\\_label::String}: Abscissa axis unit label\n\n\n\\item \\texttt{ord\\_spec\\_dtype::Int}: Ordinate specification data type\n\n\n\\item \\texttt{ord\\_len\\_unit\\_exp::Int}: Ordinate length unit exponent\n\n\n\\item \\texttt{ord\\_force\\_unit\\_exp::Int}: Ordinate force unit exponent\n\n\n\\item \\texttt{ord\\_temp\\_unit\\_exp::Int}: Ordinate temperature unit exponent\n\n\n\\item \\texttt{ord\\_axis\\_label::String}: Ordinate axis label\n\n\n\\item \\texttt{ord\\_axis\\_unit\\_label::String}: Ordinate axis unit label\n\n\n\\item \\texttt{ord\\_denom\\_spec\\_dtype::Int}: Ordinate denominator specification data type\n\n\n\\item \\texttt{ord\\_denom\\_len\\_unit\\_exp::Int}: Ordinate denominator length unit exponent\n\n\n\\item \\texttt{ord\\_denom\\_force\\_unit\\_exp::Int}: Ordinate denominator force unit exponent\n\n\n\\item \\texttt{ord\\_denom\\_temp\\_unit\\_exp::Int}: Ordinate denominator temperature unit exponent\n\n\n\\item \\texttt{ord\\_denom\\_axis\\_label::String}: Ordinate denominator axis label\n\n\n\\item \\texttt{ord\\_denom\\_axis\\_unit\\_label::String}: Ordinate denominator axis unit label\n\n\n\\item \\texttt{z\\_spec\\_dtype::Int}: Z-axis specification data type\n\n\n\\item \\texttt{z\\_len\\_unit\\_exp::Int}: Z-axis length unit exponent\n\n\n\\item \\texttt{z\\_force\\_unit\\_exp::Int}: Z-axis force unit exponent\n\n\n\\item \\texttt{z\\_temp\\_unit\\_exp::Int}: Z-axis temperature unit exponent\n\n\n\\item \\texttt{z\\_axis\\_label::String}: Z-axis label\n\n\n\\item \\texttt{z\\_axis\\_unit\\_label::String}: Z-axis unit label\n\n\n\\item \\texttt{abscissa} - Data Values (empty if evenly spaced otherwise filled in)\n\n\n\\item \\texttt{data::AbstractVector}: Data values\n\n\\end{itemize}\n"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "7",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                ":::"
            ]
        }
    ],
    "timestamp": "2025-11-24T14:18:43.102",
    "file": "/Users/maucejo/Documents/01_Recherche/04_Projets/Codes/Julia/UFFFiles/docs/datasets/dataset58b.qmd",
    "qnr_schema_version": "1.0.0"
}